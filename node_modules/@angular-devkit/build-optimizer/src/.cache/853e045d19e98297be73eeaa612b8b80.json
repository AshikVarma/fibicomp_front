{"remainingRequest":"D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\@ng-idle\\core\\src\\idle.js","dependencies":[{"path":"D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\@ng-idle\\core\\src\\idle.js","mtime":1518154215890},{"path":"D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1510929699000},{"path":"D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1518048966000}],"contextDependencies":[],"result":["import { EventEmitter, Injectable, Optional } from '@angular/core';\nimport { IdleExpiry } from './idleexpiry';\nimport { Interrupt } from './interrupt';\nimport { KeepaliveSvc } from './keepalivesvc';\nimport { LocalStorageExpiry } from './localstorageexpiry';\n/*\n * Indicates the desired auto resume behavior.\n */\nexport var AutoResume;\n(function (AutoResume) {\n    /*\n     * Auto resume functionality will be disabled.\n     */\n    AutoResume[AutoResume[\"disabled\"] = 0] = \"disabled\";\n    /*\n     * Can resume automatically even if they are idle.\n     */\n    AutoResume[AutoResume[\"idle\"] = 1] = \"idle\";\n    /*\n     * Can only resume automatically if they are not yet idle.\n     */\n    AutoResume[AutoResume[\"notIdle\"] = 2] = \"notIdle\";\n})(AutoResume || (AutoResume = {}));\n/**\n * A service for detecting and responding to user idleness.\n */\nvar Idle = /*@__PURE__*/ (function () {\n    function Idle(expiry, keepaliveSvc) {\n        this.expiry = expiry;\n        this.idle = 20 * 60; // in seconds\n        this.timeoutVal = 30; // in seconds\n        this.autoResume = AutoResume.idle;\n        this.interrupts = new Array;\n        this.running = false;\n        this.keepaliveEnabled = false;\n        this.onIdleStart = new EventEmitter;\n        this.onIdleEnd = new EventEmitter;\n        this.onTimeoutWarning = new EventEmitter();\n        this.onTimeout = new EventEmitter();\n        this.onInterrupt = new EventEmitter;\n        if (keepaliveSvc) {\n            this.keepaliveSvc = keepaliveSvc;\n            this.keepaliveEnabled = true;\n        }\n        this.setIdling(false);\n    }\n    /*\n     * Sets the idle name for localStorage.\n     * Important to set if multiple instances of Idle with LocalStorageExpiry\n     * @param The name of the idle.\n     */\n    Idle.prototype.setIdleName = function (key) {\n        if (this.expiry instanceof LocalStorageExpiry) {\n            this.expiry.setIdleName(key);\n        }\n        else {\n            throw new Error('Cannot set expiry key name because no LocalStorageExpiry has been provided.');\n        }\n    };\n    /*\n     * Returns whether or not keepalive integration is enabled.\n     * @return True if integration is enabled; otherwise, false.\n     */\n    Idle.prototype.getKeepaliveEnabled = function () {\n        return this.keepaliveEnabled;\n    };\n    /*\n     * Sets and returns whether or not keepalive integration is enabled.\n     * @param True if the integration is enabled; otherwise, false.\n     * @return The current value.\n     */\n    Idle.prototype.setKeepaliveEnabled = function (value) {\n        if (!this.keepaliveSvc) {\n            throw new Error('Cannot enable keepalive integration because no KeepaliveSvc has been provided.');\n        }\n        return this.keepaliveEnabled = value;\n    };\n    /*\n     * Returns the current timeout value.\n     * @return The timeout value in seconds.\n     */\n    Idle.prototype.getTimeout = function () {\n        return this.timeoutVal;\n    };\n    /*\n     * Sets the timeout value.\n     * @param seconds - The timeout value in seconds. 0 or false to disable timeout feature.\n     * @return The current value. If disabled, the value will be 0.\n     */\n    Idle.prototype.setTimeout = function (seconds) {\n        if (seconds === false) {\n            this.timeoutVal = 0;\n        }\n        else if (typeof seconds === 'number' && seconds >= 0) {\n            this.timeoutVal = seconds;\n        }\n        else {\n            throw new Error('\\'seconds\\' can only be \\'false\\' or a positive number.');\n        }\n        return this.timeoutVal;\n    };\n    /*\n     * Returns the current idle value.\n     * @return The idle value in seconds.\n     */\n    Idle.prototype.getIdle = function () {\n        return this.idle;\n    };\n    /*\n     * Sets the idle value.\n     * @param seconds - The idle value in seconds.\n     * @return The idle value in seconds.\n     */\n    Idle.prototype.setIdle = function (seconds) {\n        if (seconds <= 0) {\n            throw new Error('\\'seconds\\' must be greater zero');\n        }\n        return this.idle = seconds;\n    };\n    /*\n     * Returns the current autoresume value.\n     * @return The current value.\n     */\n    Idle.prototype.getAutoResume = function () {\n        return this.autoResume;\n    };\n    Idle.prototype.setAutoResume = function (value) {\n        return this.autoResume = value;\n    };\n    /*\n     * Sets interrupts from the specified sources.\n     * @param sources - Interrupt sources.\n     * @return The resulting interrupts.\n     */\n    Idle.prototype.setInterrupts = function (sources) {\n        this.clearInterrupts();\n        var self = this;\n        for (var _i = 0, sources_1 = sources; _i < sources_1.length; _i++) {\n            var source = sources_1[_i];\n            var sub = new Interrupt(source);\n            sub.subscribe(function (args) {\n                self.interrupt(args.force, args.innerArgs);\n            });\n            this.interrupts.push(sub);\n        }\n        return this.interrupts;\n    };\n    /*\n     * Returns the current interrupts.\n     * @return The current interrupts.\n     */\n    Idle.prototype.getInterrupts = function () {\n        return this.interrupts;\n    };\n    /*\n     * Pauses, unsubscribes, and clears the current interrupt subscriptions.\n     */\n    Idle.prototype.clearInterrupts = function () {\n        for (var _i = 0, _a = this.interrupts; _i < _a.length; _i++) {\n            var sub = _a[_i];\n            sub.pause();\n            sub.unsubscribe();\n        }\n        this.interrupts.length = 0;\n    };\n    /*\n     * Returns whether or not the service is running i.e. watching for idleness.\n     * @return True if service is watching; otherwise, false.\n     */\n    Idle.prototype.isRunning = function () {\n        return this.running;\n    };\n    /*\n     * Returns whether or not the user is considered idle.\n     * @return True if the user is in the idle state; otherwise, false.\n     */\n    Idle.prototype.isIdling = function () {\n        return this.idling;\n    };\n    /*\n     * Starts watching for inactivity.\n     */\n    Idle.prototype.watch = function (skipExpiry) {\n        var _this = this;\n        this.safeClearInterval('idleHandle');\n        this.safeClearInterval('timeoutHandle');\n        var timeout = !this.timeoutVal ? 0 : this.timeoutVal;\n        if (!skipExpiry) {\n            var value = new Date(this.expiry.now().getTime() + ((this.idle + timeout) * 1000));\n            this.expiry.last(value);\n        }\n        if (this.idling) {\n            this.toggleState();\n        }\n        if (!this.running) {\n            this.startKeepalive();\n            this.toggleInterrupts(true);\n        }\n        this.running = true;\n        var watchFn = function () {\n            var diff = _this.getExpiryDiff(timeout);\n            if (diff > 0) {\n                _this.safeClearInterval('idleHandle');\n                _this.idleHandle = setInterval(watchFn, diff);\n            }\n            else {\n                _this.toggleState();\n            }\n        };\n        this.idleHandle = setInterval(watchFn, this.idle * 1000);\n    };\n    /*\n     * Stops watching for inactivity.\n     */\n    Idle.prototype.stop = function () {\n        this.stopKeepalive();\n        this.toggleInterrupts(false);\n        this.safeClearInterval('idleHandle');\n        this.safeClearInterval('timeoutHandle');\n        this.setIdling(false);\n        this.running = false;\n        this.expiry.last(null);\n    };\n    /*\n     * Forces a timeout event and state.\n     */\n    Idle.prototype.timeout = function () {\n        this.stopKeepalive();\n        this.toggleInterrupts(false);\n        this.safeClearInterval('idleHandle');\n        this.safeClearInterval('timeoutHandle');\n        this.setIdling(true);\n        this.running = false;\n        this.countdown = 0;\n        this.onTimeout.emit(null);\n    };\n    /*\n     * Signals that user activity has occurred.\n     * @param force - Forces watch to be called, unless they are timed out.\n     * @param eventArgs - Optional source event arguments.\n     */\n    Idle.prototype.interrupt = function (force, eventArgs) {\n        if (!this.running) {\n            return;\n        }\n        if (this.timeoutVal && this.expiry.isExpired()) {\n            this.timeout();\n            return;\n        }\n        this.onInterrupt.emit(eventArgs);\n        if (force === true || this.autoResume === AutoResume.idle ||\n            (this.autoResume === AutoResume.notIdle && !this.expiry.idling())) {\n            this.watch(force);\n        }\n    };\n    Idle.prototype.setIdling = function (value) {\n        this.idling = value;\n        this.expiry.idling(value);\n    };\n    Idle.prototype.toggleState = function () {\n        var _this = this;\n        this.setIdling(!this.idling);\n        if (this.idling) {\n            this.onIdleStart.emit(null);\n            this.stopKeepalive();\n            if (this.timeoutVal > 0) {\n                this.countdown = this.timeoutVal;\n                this.doCountdown();\n                this.timeoutHandle = setInterval(function () {\n                    _this.doCountdown();\n                }, 1000);\n            }\n        }\n        else {\n            this.toggleInterrupts(true);\n            this.onIdleEnd.emit(null);\n            this.startKeepalive();\n        }\n        this.safeClearInterval('idleHandle');\n    };\n    Idle.prototype.toggleInterrupts = function (resume) {\n        for (var _i = 0, _a = this.interrupts; _i < _a.length; _i++) {\n            var interrupt = _a[_i];\n            if (resume) {\n                interrupt.resume();\n            }\n            else {\n                interrupt.pause();\n            }\n        }\n    };\n    Idle.prototype.getExpiryDiff = function (timeout) {\n        var now = this.expiry.now();\n        var last = this.expiry.last() || now;\n        return last.getTime() - now.getTime() - (timeout * 1000);\n    };\n    Idle.prototype.doCountdown = function () {\n        var timeout = !this.timeoutVal ? 0 : this.timeoutVal;\n        var diff = this.getExpiryDiff(timeout);\n        if (diff > 0) {\n            this.safeClearInterval('timeoutHandle');\n            this.interrupt(true);\n            return;\n        }\n        if (!this.idling) {\n            return;\n        }\n        if (this.countdown <= 0) {\n            this.timeout();\n            return;\n        }\n        this.onTimeoutWarning.emit(this.countdown);\n        this.countdown--;\n    };\n    Idle.prototype.safeClearInterval = function (handleName) {\n        if (this[handleName]) {\n            clearInterval(this[handleName]);\n            this[handleName] = null;\n        }\n    };\n    Idle.prototype.startKeepalive = function () {\n        if (!this.keepaliveSvc || !this.keepaliveEnabled) {\n            return;\n        }\n        if (this.running) {\n            this.keepaliveSvc.ping();\n        }\n        this.keepaliveSvc.start();\n    };\n    Idle.prototype.stopKeepalive = function () {\n        if (!this.keepaliveSvc || !this.keepaliveEnabled) {\n            return;\n        }\n        this.keepaliveSvc.stop();\n    };\n    /*\n     * Called by Angular when destroying the instance.\n     */\n    Idle.prototype.ngOnDestroy = function () {\n        this.stop();\n        this.clearInterrupts();\n    };\n    return Idle;\n}());\nexport { Idle };\n//# sourceMappingURL=idle.js.map \n",null]}