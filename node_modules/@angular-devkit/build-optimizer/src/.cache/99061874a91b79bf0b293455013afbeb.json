{"remainingRequest":"D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\elasticsearch\\src\\lib\\connection.js","dependencies":[{"path":"D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\elasticsearch\\src\\lib\\connection.js","mtime":1518154263554},{"path":"D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1510929699000},{"path":"D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1518048966000}],"contextDependencies":[],"result":["module.exports = ConnectionAbstract;\n\nvar _ = require('./utils');\nvar EventEmitter = require('events').EventEmitter;\nvar Log = require('./log');\nvar Host = require('./host');\nvar errors = require('./errors');\n\n/**\n * Abstract class used for Connection classes\n * @class ConnectionAbstract\n * @constructor\n */\nfunction ConnectionAbstract(host, config) {\n  config = config || {};\n  EventEmitter.call(this);\n\n  this.log = config.log || new Log();\n  this.pingTimeout = config.pingTimeout || 3000;\n\n  if (!host) {\n    throw new TypeError('Missing host');\n  } else if (host instanceof Host) {\n    this.host = host;\n  } else {\n    throw new TypeError('Invalid host');\n  }\n\n  _.makeBoundMethods(this);\n}\n_.inherits(ConnectionAbstract, EventEmitter);\n\n/**\n * Make a request using this connection. Must be overridden by Connection classes, which can add whatever keys to\n * params that they like. These are just the basics.\n *\n * @param [params] {Object} - The parameters for the request\n * @param params.path {String} - The path for which you are requesting\n * @param params.method {String} - The HTTP method for the request (GET, HEAD, etc.)\n * @param params.requestTimeout {Integer} - The amount of time in milliseconds that this request should be allowed to run for.\n * @param cb {Function} - A callback to be called once with `cb(err, responseBody, responseStatus)`\n */\nConnectionAbstract.prototype.request = function () {\n  throw new Error('Connection#request must be overwritten by the Connector');\n};\n\nConnectionAbstract.prototype.ping = function (params, cb) {\n  if (typeof params === 'function') {\n    cb = params;\n    params = null;\n  } else {\n    cb = typeof cb === 'function' ? cb : null;\n  }\n\n  var requestTimeout = this.pingTimeout;\n  var requestTimeoutId;\n  var aborted;\n  var abort;\n\n  if (params && params.hasOwnProperty('requestTimeout')) {\n    requestTimeout = params.requestTimeout;\n  }\n\n  abort = this.request(_.defaults(params || {}, {\n    path: '/',\n    method: 'HEAD'\n  }), function (err) {\n    if (aborted) {\n      return;\n    }\n    clearTimeout(requestTimeoutId);\n    if (cb) {\n      cb(err);\n    }\n  });\n\n  if (requestTimeout) {\n    requestTimeoutId = setTimeout(function () {\n      if (abort) {\n        abort();\n      }\n      aborted = true;\n      if (cb) {\n        cb(new errors.RequestTimeout('Ping Timeout after ' + requestTimeout + 'ms'));\n      }\n    }, requestTimeout);\n  }\n};\n\nConnectionAbstract.prototype.setStatus = function (status) {\n  var origStatus = this.status;\n  this.status = status;\n\n  this.emit('status set', status, origStatus, this);\n\n  if (status === 'closed') {\n    this.removeAllListeners();\n  }\n};\n",null]}