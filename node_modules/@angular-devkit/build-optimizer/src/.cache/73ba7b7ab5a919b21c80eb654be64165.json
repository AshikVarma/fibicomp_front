{"remainingRequest":"D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\elasticsearch\\src\\lib\\transport\\sniff_on_connection_fault.js","dependencies":[{"path":"D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\elasticsearch\\src\\lib\\transport\\sniff_on_connection_fault.js","mtime":1518154263816},{"path":"D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1510929699000},{"path":"D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1518048966000}],"contextDependencies":[],"result":["var _ = require('../utils');\n\n\n/**\n * Patch the transport's connection pool to schedule a sniff after a connection fails.\n * When a connection fails for the first time it will schedule a sniff 1 second in the\n * future, and increase the timeout based on the deadTimeout algorithm chosen by the\n * connectionPool, and the number of times the sniff has failed.\n *\n * @param  {Transport} transport - the transport that will be using this behavior\n * @return {undefined}\n */\nmodule.exports = function setupSniffOnConnectionFault(transport) {\n  var failures = 0;\n  var pool = transport.connectionPool;\n  var originalOnDied = pool._onConnectionDied;\n\n  // do the actual sniff, if the sniff is unable to\n  // connect to a node this function will be called again by the connectionPool\n  var work = function () {\n    work.timerId = transport._timeout(work.timerId);\n    transport.sniff();\n  };\n\n  // create a function that will count down to a\n  // point n milliseconds into the future\n  var countdownTo = function (ms) {\n    var start = _.now();\n    return function () {\n      return start - ms;\n    };\n  };\n\n  // overwrite the function, but still call it\n  pool._onConnectionDied = function (connection, wasAlreadyDead) {\n    var ret = originalOnDied.call(pool, connection, wasAlreadyDead);\n\n    // clear the failures if this is the first failure we have seen\n    failures = work.timerId ? failures + 1 : 0;\n\n    var ms = pool.calcDeadTimeout(failures, 1000);\n\n    if (work.timerId && ms < work.timerId && work.countdown()) {\n      // clear the timer\n      work.timerId = transport._timeout(work.timerId);\n    }\n\n    if (!work.timerId) {\n      work.timerId = transport._timeout(work, ms);\n      work.countdown = countdownTo(ms);\n    }\n\n    return ret;\n  };\n\n  pool._onConnectionDied.restore = function () {\n    pool._onConnectionDied = originalOnDied;\n  };\n};\n",null]}