{"remainingRequest":"D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\@ng-idle\\core\\src\\eventtargetinterruptsource.js","dependencies":[{"path":"D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\@ng-idle\\core\\src\\eventtargetinterruptsource.js","mtime":1518154215858},{"path":"D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1510929699000},{"path":"D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1518048966000}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport 'rxjs/add/operator/throttleTime';\r\nimport 'rxjs/add/observable/fromEvent';\r\nimport { Observable } from 'rxjs/Observable';\r\nimport { InterruptArgs } from './interruptargs';\r\nimport { InterruptSource } from './interruptsource';\r\n/*\r\n * An interrupt source on an EventTarget object, such as a Window or HTMLElement.\r\n */\r\nvar EventTargetInterruptSource = /*@__PURE__*/ (function (_super) {\r\n    __extends(EventTargetInterruptSource, _super);\r\n    function EventTargetInterruptSource(target, events, throttleDelay) {\r\n        if (throttleDelay === void 0) {\r\n            throttleDelay = 500;\r\n        }\r\n        var _this = _super.call(this, null, null) || this;\r\n        _this.target = target;\r\n        _this.events = events;\r\n        _this.throttleDelay = throttleDelay;\r\n        _this.eventSrc = new Array;\r\n        _this.eventSubscription = new Array;\r\n        var self = _this;\r\n        events.split(' ').forEach(function (event) {\r\n            var src = Observable.fromEvent(target, event);\r\n            if (self.throttleDelay > 0) {\r\n                src = src.throttleTime(self.throttleDelay);\r\n            }\r\n            self.eventSrc.push(src);\r\n        });\r\n        var handler = function (innerArgs) {\r\n            if (self.filterEvent(innerArgs)) {\r\n                return;\r\n            }\r\n            var args = new InterruptArgs(this, innerArgs);\r\n            self.onInterrupt.emit(args);\r\n        };\r\n        _this.attachFn = function () {\r\n            _this.eventSrc.forEach(function (src) {\r\n                self.eventSubscription.push(src.subscribe(handler));\r\n            });\r\n        };\r\n        _this.detachFn = function () {\r\n            _this.eventSubscription.forEach(function (sub) {\r\n                sub.unsubscribe();\r\n            });\r\n            _this.eventSubscription.length = 0;\r\n        };\r\n        return _this;\r\n    }\r\n    /*\r\n     * Checks to see if the event should be filtered. Always returns false unless overriden.\r\n     * @param event - The original event object.\r\n     * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.\r\n     */\r\n    EventTargetInterruptSource.prototype.filterEvent = function (event) {\r\n        return false;\r\n    };\r\n    return EventTargetInterruptSource;\r\n}(InterruptSource));\r\nexport { EventTargetInterruptSource };\r\n//# sourceMappingURL=eventtargetinterruptsource.js.map \r\n",null]}