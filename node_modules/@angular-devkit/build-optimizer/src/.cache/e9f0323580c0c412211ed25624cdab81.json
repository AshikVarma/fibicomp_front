{"remainingRequest":"D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\elasticsearch\\src\\lib\\utils.js","dependencies":[{"path":"D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\elasticsearch\\src\\lib\\utils.js","mtime":1518154263828},{"path":"D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1510929699000},{"path":"D:\\fibicomp-frontend\\fibicomp_front\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1518048966000}],"contextDependencies":[],"result":["var path = require('path');\nvar nodeUtils = require('util');\nvar lodash = require('lodash');\n\n/**\n * Custom utils library, basically a modified version of [lodash](http://lodash.com/docs) +\n * [node.utils](http://nodejs.org/api/util.html#util_util) that doesn't use mixins to prevent\n * confusion when requiring lodash itself.\n *\n * @class utils\n * @static\n */\nvar _ = lodash.assign({}, lodash, nodeUtils);\n\n/**\n * Link to [path.join](http://nodejs.org/api/path.html#path_path_join_path1_path2)\n *\n * @method _.joinPath\n * @type {function}\n */\n_.joinPath = path.join;\n\n_.get = require('lodash.get');\n_.trimEnd = require('lodash.trimend');\n\n/**\n * Recursively merge two objects, walking into each object and concating arrays. If both to and from have a value at a\n * key, but the values' types don't match to's value is left unmodified. Only Array and Object values are merged - that\n * it to say values with a typeof \"object\"\n *\n * @param  {Object} to - Object to merge into (no cloning, the original object\n *   is modified)\n * @param  {Object} from - Object to pull changed from\n * @return {Object} - returns the modified to value\n */\n_.deepMerge = function (to, from) {\n  _.each(from, function (fromVal, key) {\n    switch (typeof to[key]) {\n      case 'undefined':\n        to[key] = from[key];\n        break;\n      case 'object':\n        if (_.isArray(to[key]) && _.isArray(from[key])) {\n          to[key] = to[key].concat(from[key]);\n        }\n        else if (_.isPlainObject(to[key]) && _.isPlainObject(from[key])) {\n          _.deepMerge(to[key], from[key]);\n        }\n    }\n  });\n  return to;\n};\n\n/**\n * Test if a value is an array and it's contents are of a specific type\n *\n * @method isArrayOf<Strings|Object|Array|Finite|Function|RegExp>s\n * @param  {Array} arr - An array to check\n * @return {Boolean}\n */\n_.each([\n  'String',\n  'Object',\n  'PlainObject',\n  'Array',\n  'Finite',\n  'Function',\n  'RegExp'\n], function (type) {\n  var check = _['is' + type];\n\n  _['isArrayOf' + type + 's'] = function (arr) {\n    // quick shallow check of arrays\n    return _.isArray(arr) && _.every(arr.slice(0, 10), check);\n  };\n});\n\n\n/**\n * Capitalize the first letter of a word\n *\n * @method  ucfirst\n * @param  {string} word - The word to transform\n * @return {string}\n */\n_.ucfirst = function (word) {\n  return word[0].toUpperCase() + word.substring(1).toLowerCase();\n};\n\n/**\n * Base algo for studlyCase and camelCase\n * @param  {boolean} firstWordCap - Should the first character of the first word be capitalized\n * @return {Function}\n */\nfunction adjustWordCase(firstWordCap, otherWordsCap, sep) {\n  return function (string) {\n    var i = 0;\n    var words = [];\n    var word = '';\n    var code, c, upper, lower;\n\n    for (; i < string.length; i++) {\n      code = string.charCodeAt(i);\n      c = string.charAt(i);\n      lower = (code >= 97 && code <= 122) || (code >= 48 && code <= 57);\n      upper = code >= 65 && code <= 90;\n\n      if (upper || !lower) {\n        // new word\n        if (word.length) {\n          words.push(word);\n        }\n        word = '';\n      }\n\n      if (upper || lower) {\n        if (lower && word.length) {\n          word += c;\n        } else {\n          if ((!words.length && firstWordCap) || (words.length && otherWordsCap)) {\n            word = c.toUpperCase();\n          }\n          else {\n            word = c.toLowerCase();\n          }\n        }\n      }\n    }\n    if (word.length) {\n      words.push(word);\n    }\n    // add the leading underscore back to strings the had it originally\n    if (words.length && string.charAt(0) === '_') {\n      words[0] = '_' + words[0];\n    }\n    return words.join(sep);\n  };\n}\n\n/**\n * Transform a string into StudlyCase\n *\n * @method studlyCase\n * @param  {String} string\n * @return {String}\n */\n_.studlyCase = adjustWordCase(true, true, '');\n\n/**\n * Transform a string into camelCase\n *\n * @method camelCase\n * @param  {String} string\n * @return {String}\n */\n_.camelCase = adjustWordCase(false, true, '');\n\n/**\n * Transform a string into snakeCase\n *\n * @method snakeCase\n * @param  {String} string\n * @return {String}\n */\n_.snakeCase = adjustWordCase(false, false, '_');\n\n/**\n * Lower-case a string, and return an empty string if any is not a string\n *\n * @param any {*} - Something or nothing\n * @returns {string}\n */\n_.toLowerString = function (any) {\n  if (any) {\n    if (typeof any !== 'string') {\n      any = any.toString();\n    }\n  } else {\n    any = '';\n  }\n  return any.toLowerCase();\n};\n\n/**\n * Upper-case the string, return an empty string if any is not a string\n *\n * @param any {*} - Something or nothing\n * @returns {string}\n */\n_.toUpperString = function (any) {\n  if (any) {\n    if (typeof any !== 'string') {\n      any = any.toString();\n    }\n  } else {\n    any = '';\n  }\n  return any.toUpperCase();\n};\n\n/**\n * Test if a value is \"numeric\" meaning that it can be transformed into something besides NaN\n *\n * @method isNumeric\n * @param  {*} val\n * @return {Boolean}\n */\n_.isNumeric = function (val) {\n  return typeof val !== 'object' && val - parseFloat(val) >= 0;\n};\n\n// regexp to test for intervals\nvar intervalRE = /^(\\d+(?:\\.\\d+)?)(M|w|d|h|m|s|y|ms)$/;\n\n/**\n * Test if a string represents an interval (eg. 1m, 2Y)\n *\n * @method isInterval\n * @param {String} val\n * @return {Boolean}\n */\n_.isInterval = function (val) {\n  return !!(val.match && val.match(intervalRE));\n};\n\n/**\n * Repeat a string n times\n *\n * @todo TestPerformance\n * @method repeat\n * @param {String} what - The string to repeat\n * @param {Number} times - Times the string should be repeated\n * @return {String}\n */\n_.repeat = function (what, times) {\n  return (new Array(times + 1)).join(what);\n};\n\n/**\n * Call a function, applying the arguments object to it in an optimized way, rather than always turning it into an array\n *\n * @param func {Function} - The function to execute\n * @param context {*} - The context the function will be executed with\n * @param args {Arguments} - The arguments to send to func\n * @param [sliceIndex=0] {Integer} - The index that args should be sliced at, before feeding args to func\n * @returns {*} - the return value of func\n */\n_.applyArgs = function (func, context, args, sliceIndex) {\n  sliceIndex = sliceIndex || 0;\n  switch (args.length - sliceIndex) {\n    case 0:\n      return func.call(context);\n    case 1:\n      return func.call(context, args[0 + sliceIndex]);\n    case 2:\n      return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex]);\n    case 3:\n      return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex], args[2 + sliceIndex]);\n    case 4:\n      return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex], args[2 + sliceIndex], args[3 + sliceIndex]);\n    case 5:\n      return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex],\n      args[2 + sliceIndex], args[3 + sliceIndex], args[4 + sliceIndex]);\n    default:\n      return func.apply(context, Array.prototype.slice.call(args, sliceIndex));\n  }\n};\n\n/**\n * Schedule a function to be called on the next tick, and supply it with these arguments\n * when it is called.\n * @return {[type]} [description]\n */\n_.nextTick = function (cb) {\n  // bind the function and schedule it\n  process.nextTick(_.bindKey(_, 'applyArgs', cb, null, arguments, 1));\n};\n\n/**\n * Marks a method as a handler. Currently this just makes a property on the method\n * flagging it to be bound to the object at object creation when \"makeBoundMethods\" is called\n *\n * ```\n * ClassName.prototype.methodName = _.handler(function () {\n *   // this will always be bound when called via classInstance.bound.methodName\n *   this === classInstance\n * });\n * ```\n *\n * @alias _.scheduled\n * @param  {Function} func - The method that is being defined\n * @return {Function}\n */\n_.handler = function (func) {\n  func._provideBound = true;\n  return func;\n};\n_.scheduled = _.handler;\n\n/**\n * Creates an \"bound\" property on an object, which all or a subset of methods from\n * the object which are bound to the original object.\n *\n * ```\n * var obj = {\n *   onEvent: function () {}\n * };\n *\n * _.makeBoundMethods(obj);\n *\n * obj.bound.onEvent() // is bound to obj, and can safely be used as an event handler.\n * ```\n *\n * @param {Object} obj - The object to bind the methods to\n */\n_.makeBoundMethods = function (obj) {\n  obj.bound = {};\n  for (var prop in obj) {\n    // dearest maintainer, we want to look through the prototype\n    if (typeof obj[prop] === 'function' && obj[prop]._provideBound === true) {\n      obj.bound[prop] = _.bind(obj[prop], obj);\n    }\n  }\n};\n\n_.noop = function () {};\n\n/**\n * Implements the standard \"string or constructor\" check that I was copy/pasting everywhere\n * @param  {String|Function} val - the value that the user passed in\n * @param  {Object} opts - a map of the options\n * @return {Function|undefined} - If a valid option was specified, then the constructor is returned\n */\n_.funcEnum = function (config, name, opts, def) {\n  var val = config[name];\n  switch (typeof val) {\n    case 'undefined':\n      return opts[def];\n    case 'function':\n      return val;\n    case 'string':\n      if (opts.hasOwnProperty(val)) {\n        return opts[val];\n      }\n    /* falls through */\n    default:\n      var err = 'Invalid ' + name + ' \"' + val + '\", expected a function';\n      switch (_.size(opts)) {\n        case 0:\n          break;\n        case 1:\n          err += ' or ' + _.keys(opts)[0];\n          break;\n        default:\n          err += ' or one of ' + _.keys(opts).join(', ');\n          break;\n      }\n      throw new TypeError(err);\n  }\n};\n\n/**\n * Accepts any object and attempts to convert it into an array. If the object passed in is not\n * an array it will be wrapped in one. Then the transform/map function will be called for each element\n * and create a new array that is returned. If the map function fails to return something, the loop is\n * halted and false is returned instead of an array.\n *\n * @param  {*} input - The value to convert\n * @param  {Function} transform - A function called for each element of the resulting array\n * @return {Array|false} - an array on success, or false on failure.\n */\n_.createArray = function (input, transform) {\n  transform = typeof transform === 'function' ? transform : _.identity;\n  var output = [];\n  var item;\n  var i;\n\n  if (!_.isArray(input)) {\n    input = [input];\n  }\n\n  for (i = 0; i < input.length; i++) {\n    item = transform(input[i]);\n    if (item === void 0) {\n      return false;\n    } else {\n      output.push(item);\n    }\n  }\n  return output;\n};\n\n/**\n * Takes a WritableStream, and returns the chunks that have not successfully written, returning them as a string.\n *\n * ONLY WORKS FOR TEXT STREAMS\n *\n * @param  {WritableStream} stream - an instance of stream.Writable\n * @return {string} - the remaining test to be written to the stream\n */\n_.getUnwrittenFromStream = function (stream) {\n  var writeBuffer = _.getStreamWriteBuffer(stream);\n  if (!writeBuffer) return;\n\n  // flush the write buffer\n  var out = '';\n  if (!writeBuffer.length) return out;\n\n  _.each(writeBuffer, function (writeReq) {\n    if (writeReq.chunk) {\n      // 0.9.12+ uses WriteReq objects with a chunk prop\n      out += '' + writeReq.chunk;\n    } else if (_.isArray(writeReq) && (typeof writeReq[0] === 'string' || Buffer.isBuffer(writeReq[0]))) {\n      // 0.9.4 - 0.9.9 buffers are arrays of arrays like [[chunk, cb], [chunk, undef], ...].\n      out += '' + writeReq[0];\n    } else {\n      return false;\n    }\n  });\n  return out;\n};\n\n_.getStreamWriteBuffer = function (stream) {\n  if (!stream || !stream._writableState) return;\n\n  var writeState = stream._writableState;\n\n  if (writeState.getBuffer) {\n    return writeState.getBuffer();\n  } else if (writeState.buffer) {\n    return writeState.buffer;\n  }\n};\n\n_.clearWriteStreamBuffer = function (stream) {\n  var buffer = _.getStreamWriteBuffer(stream);\n  return buffer && buffer.splice(0);\n};\n\n/**\n * return the current time in milliseconds since epoch\n */\n_.now = function () {\n  return (typeof Date.now === 'function') ? Date.now() : (new Date()).getTime();\n};\n\nmodule.exports = _;\n",null]}